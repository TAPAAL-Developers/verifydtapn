#include "VectorizedMPPMarking.hpp"
#include <cstring>
#include <iostream>
#include <stdio.h>
//#include <xmmintrin.h>

namespace VerifyTAPN {

	boost::shared_ptr<TAPN::TimedArcPetriNet> VectorizedMPPMarking::tapn;

	void VectorizedMPPMarking::InitZero() {
		n = dp.size() + 1;
		G = std::vector<int>(n, 0);
		gens = 1;
	}

	void VectorizedMPPMarking::InitMapping() {
		for (unsigned int i = 0; i < dp.size(); i++) {
			mapping.SetMapping(i, i + 1);
		}
	}

	/* Function to calculate whether 1 arbitrary point is contained in (can be
	 * generated by) the polyhedron
	 * x is the vector containing the point
	 * ac is a vector telling which clocks are active
	 * skipGen is used when calculating whether a generator of a polyhedron is redundant. In this case the index of the concerned generator
	 * is passed to indicate that it is not a part of the polyhedron without it
	 * skipGen defaults to -1 which does not macth any generator index
	 */
	bool VectorizedMPPMarking::ContainsPoint(const std::vector<int>& x, int skipGen) const {
		std::vector<int> y = std::vector<int>(gens, INF);
		std::vector<int> z = std::vector<int>(n, INT_MIN);

		for (unsigned int i = 0; i < gens; i++) {
			if (i != skipGen) {
				for (unsigned int j = 0; j < n; j++) {
					if (G.at(i * n + j) == INT_MIN) {
						// y.at(i) does not change since we get MIN(y_val, x_val - -INF) => MIN(y_val, INF)
					} else if (x.at(j) == INT_MIN) {
						y.at(i) = INT_MIN;
					} else {
						y.at(i) = MIN(y.at(i), x.at(j) - G.at(i*n+j));
					}
				}
			}
		}
		for (unsigned int j = 0; j < n; j++) {
			for (unsigned int i = 0; i < gens; i++) {
				if (i != skipGen) {
					if (y.at(i) >= INF || G.at(i * n + j) >= INF || z.at(j) >= INF) {
						//the generator x we check for containment cannot have the value INF in any dimension
					} else if (y.at(i) == INT_MIN || G.at(i * n + j) == INT_MIN) {
						//z.at(j) should not change since we're interested in MAX and the result of y_val + G_val will be -INFINITY
						//and z is for all coordinates initialized to be INT_MIN
					} else {
						z.at(j) = MAX(z.at(j), y.at(i)+G.at(i*n+j));
					}
				}
			}
			if (x.at(j) != z.at(j)) {
				return false;
			}
		}
		return true;
	}

	/* Function to determine whether a given polyhedron is contained in this
	 *
	 */
	bool VectorizedMPPMarking::Contains(const VectorizedMPPMarking& mpp) const {
		std::vector<int> x = std::vector<int>(n);

		for (unsigned int i = 0; i < mpp.gens; i++) {
			std::memcpy(&x.at(0), &mpp.G.at(i * n), sizeof(int) * n); //extracting one generator from mpp copying it to x

			//		for (unsigned int j = 0; j < NumberOfTokens(); ++j) {
			//			if (GetClockIndex(j) != mpp.GetClockIndex(j)) {
			//				int temp = x.at(GetClockIndex(j));
			//				x.at(GetClockIndex(j)) = x.at(mpp.GetClockIndex(j));
			//				x.at(mpp.GetClockIndex(j)) = temp;
			//
			//				}
			//			}

			if (!ContainsPoint(x)) {
				return false;
			}
		}
		return true;
	}

	/* Function to intersect this with a half-space
	 * a max-plus half-space is here used to represent a difference constraint
	 * a and b are generators defining the half-space
	 */
	void VectorizedMPPMarking::IntersectHalfspace(std::vector<int>& a, std::vector<int>& b) {
		std::vector<int> Ggt; //"set" G^greather_than
		Ggt.reserve(G.size() - n); //reserve space to potentially hold all generators of G but one. In case all generators goes to Ggt the intersection is empty
		int GgtGens = 0; // number of generators in Ggt

		for (unsigned int i = 0; i < gens; i++) {
			int ag = INT_MIN; //to contain max-plus dot products (a * G^i)
			int bg = INT_MIN; //and (b * G^i)
			for (unsigned int j = 0; j < n; j++) {
				if (a.at(j) == INT_MIN || G.at(i * n + j) == INT_MIN) {
					//ag is either itself or INT_MIN which it was initialized as
					//a_j + G^i_j = INT_MIN in either case
				} else {
					ag = MAX(ag, a.at(j) + G.at(i*n+j));
				}
				if (b.at(j) == INT_MIN || G.at(i * n + j) == INT_MIN) {
					//same as above (ag) for bg
				} else {
					bg = MAX(bg, b.at(j) + G.at(i*n+j));
				}
			}
			if (ag > bg) {
				Ggt.resize(Ggt.size() + n); //resizing Ggt to have space for another generator
				std::memcpy(&Ggt.at(GgtGens * n), &G.at(i * n), sizeof(int) * n); //copying generator to Ggt "set"
				GgtGens++;
				if (i < gens - 1) {
					std::memcpy(&G.at(i * n), &G.at((gens - 1) * n), sizeof(int) * n); //moving last generator to empty space just created from removing a generator
					i--; //loop need to handle just moved generator
				}
				gens--;
				G.resize(gens * n); //resizing g to drop last generator which was just moved (might not be necessary as we keep count of generators and do a additional resize just below)
			}
		}
		if (gens == 0 || GgtGens == 0) {
			return;
		}

		int GleqGens = gens;
		G.resize(gens * n + GleqGens * GgtGens * n); //resize to fit the extra generators to be added

		for (int g = 0; g < GleqGens; g++) {
			for (int h = 0; h < GgtGens; h++) {
				std::vector<int> generator = std::vector<int>(n, INT_MIN);
				int ah = INT_MIN; // to hold dotproduct of a and h
				int bg = INT_MIN; // dot product for b and g
				for (unsigned int j = 0; j < n; j++) {
					if (a.at(j) == INT_MIN || Ggt.at(h * n + j) == INT_MIN) {
						//nothing, result = INT_MIN
					} else {
						ah = MAX(ah, a.at(j)+Ggt.at(h*n+j));
					}
					if (b.at(j) == INT_MIN || G.at(g * n + j) == INT_MIN) {
						//nothing, result = INT_MIN
					} else {
						bg = MAX(bg, b.at(j)+G.at(g*n+j));
					}
				}
				for (unsigned int j = 0; j < n; j++) {
					if (ah == INT_MIN || G.at(g * n + j) == INT_MIN) {
						if (bg == INT_MIN || Ggt.at(h * n + j) == INT_MIN) {
							//generator.at(j) = INT_MIN which it already is initialised to
						} else {
							generator.at(j) = bg + Ggt.at(h * n + j);
						}
					} else if (bg == INT_MIN || Ggt.at(h * n + j) == INT_MIN) {
						generator.at(j) = ah + G.at(g * n + j);
					} else {
						generator.at(j) = MAX(ah+G.at(g*n+j), bg+Ggt.at(h*n+j));
					}
				}
				std::memcpy(&G.at(gens * n), &generator.at(0), sizeof(int) * n); //copying newly created generator into the end of G
				gens++;
			}
		}
	}

	/*
	 * function to remove redundant generators
	 */
	void VectorizedMPPMarking::Cleanup() {
		std::vector<int> g = std::vector<int>(n);
		for (int i = gens - 1; i >= 0; --i) {
			std::memcpy(&g.at(0), &G.at(i * n), sizeof(int) * n); //extracting a generator
			if (ContainsPoint(g, i)) { //passing i to reflect the given generator should be ignored in the containment calculation
				if (i < gens - 1) { //checking whether the given generator is the last one or not. If not the last one has to be moved to keep data compact
					std::memcpy(&G.at(i * n), &G.at((gens - 1) * n), sizeof(int) * n);
				}
				gens--;
				G.resize(gens * n);
			}
		}
	}

	/*
	 * output sensitive cleanup
	 * naive implementation - copying around a lot of data, which should be avoided if possible
	 * TODO - need to figure out a clever way to implement -- ALGORITHM NOT COMPLEATE
	 */
	void VectorizedMPPMarking::CleanupOS() {
		std::vector<int> E = std::vector<int>(n); //extreme generators
		int lexmin = Lexmin(G, gens);
		unsigned int Egens = 1;
		memcpy(&E.at(0), &G.at(lexmin * n), sizeof(int) * n); //initializing E with lexicpgraphical minimum
		G.erase(G.begin() + lexmin * n, G.begin() + lexmin * n + n);
		gens--;
		std::vector<int> x = std::vector<int>(n); //generator to check inclusion for
		for (int i = gens - 1; i >= 0; i--) {
			std::memcpy(&x.at(0), &G.at(i * n), sizeof(int) * n);
			if (ExSetContainsPoint(E, Egens, x)) {
				G.erase(G.begin() + (i * n), G.begin() + (i * n) + n);
			} else {
				std::vector<int> y = std::vector<int>(n, INF); //vector holding (E\x)
				std::vector<int> satDim = std::vector<int>(n, 0);
				for (unsigned int e = 0; e < Egens; e++) {
					std::vector<int> sat;
					for (unsigned int j = 0; j < n; j++) {
						if (E.at(e * n + j) == INT_MIN) {
							// y.at(i) does not change since we get MIN(y_val, x_val - -INF) => MIN(y_val, INF)
						} else if (x.at(j) == INT_MIN) {
							if (y.at(e) != INT_MIN) {
								y.at(e) = INT_MIN;
								sat.clear();
							}
							sat.push_back(j);
						} else if (y.at(e) > x.at(j) - E.at(e * n + j)) {
							sat.clear();
							sat.push_back(j);
							y.at(e) = x.at(j) - E.at(e * n + j);
						} else if (y.at(e) == x.at(j) - E.at(e * n + j)) {
							sat.push_back(j);
						}
					}
					for (unsigned int s = 0; s < sat.size(); s++) {
						satDim.at(sat.at(s)) = 1;
					}
				}
				for (unsigned int j = 0; j < n; j++) {
					if (satDim.at(j)) {
						std::vector<int> Z;
						std::vector<int> Zgens;
						int minPsi = INF;
						for (unsigned int g = 0; g < gens; g++) {
							if (minPsi == INT_MIN) {

							}
						}
					}
				}
			}
		}
	}

	/*
	 * calculating ARGMAX_{z â‚¬ P}(psi(z))
	 * where psi(x) = x_i - w_i - max_{j!=i}(x_j - w_j)
	 * i = dim
	 * Zgens is a vector containing the generator indexes of the generators satisfying the argmax
	 * TODO -- Algorithm is not finished!!
	 */
	std::vector<int> VectorizedMPPMarking::ArgmaxPsi(const std::vector<int>& P, int Pgens, int dim, const std::vector<
			int> w, int skipgen) const {
		int maxPsi = INT_MIN;
		std::vector<int> Zgens;
		for (int i = 0; i < Pgens; i++) {
			if (i != skipgen) {
				int max = INT_MIN; // max_{j!=dim}(p_j - w_j)
				for (unsigned int j = 0; j < n; j++) {
					if (j != dim) {
						if (w.at(j) == INT_MIN) {
							max = INF;
						} else if (P.at(i * n + j) == INT_MIN) {

						} else {

						}
					}
				}
			}
		}
		return Zgens;
	}

	/*
	 * determines whether a point can be generated by a cone C given as a vector and the number of generators of C
	 */
	bool VectorizedMPPMarking::ExSetContainsPoint(const std::vector<int>& C, int Cgens, const std::vector<int>& x) const {
		std::vector<int> y = std::vector<int>(gens, INF);
		std::vector<int> z = std::vector<int>(n, INT_MIN);

		for (unsigned int i = 0; i < Cgens; i++) {
			for (unsigned int j = 0; j < n; j++) {
				if (C.at(i * n + j) == INT_MIN) {
					// y.at(i) does not change since we get MIN(y_val, x_val -(-INF)) => MIN(y_val, INF)
				} else if (x.at(j) == INT_MIN) {
					y.at(i) = INT_MIN;
				} else {
					y.at(i) = MIN(y.at(i), x.at(j) - C.at(i*n+j));
				}
			}
		}
		for (unsigned int j = 0; j < n; j++) {
			for (unsigned int i = 0; i < Cgens; i++) {
				if (y.at(i) >= INF || C.at(i * n + j) >= INF || z.at(j) >= INF) {
					//the generator x we check for containment cannot have the value INF in any dimension
				} else if (y.at(i) == INT_MIN || C.at(i * n + j) == INT_MIN) {
					//z.at(j) should not change since we're interested in MAX and the result of y_val + G_val will be -INFINITY
					//and z is for all coordinates initialized to be INT_MIN
				} else {
					z.at(j) = MAX(z.at(j), y.at(i)+C.at(i*n+j));
				}
			}
			if (x.at(j) != z.at(j)) {
				return false;
			}
		}
		return true;
	}

	/*
	 * normalizing the generators, such that the first coordinate different from
	 * INT_MIN is 0
	 */
	void VectorizedMPPMarking::Norm() {
		for (unsigned int i = 0; i < gens; i++) {
			int temp = INT_MIN;
			for (unsigned int j = 0; j < n; j++) {
				if (temp == INT_MIN && G.at(i * n + j) != INT_MIN) {
					temp = G.at(i * n + j);
				}
				if (temp != INT_MIN && G.at(i * n + j) != INT_MIN) {
					G.at(i * n + j) -= temp;
				}
			}
		}
	}

	/*
	 * returning the index of the Lexicographical minimal generator, to a specified dimension, of the cone C
	 * if no dimension is specified dim 0 is defeault
	 * dim: the dimension we want the lexmin over
	 * C: a vector containing the generators of the cone
	 * Cgens: the numbers of generators of C
	 */
	int VectorizedMPPMarking::Lexmin(const std::vector<int>& C, unsigned int Cgens, unsigned int dim) const {
		std::vector<int> posMins;
		bool initValNegInf = false;
		for (unsigned int i = 0; i < Cgens; i++) {
			if (C.at(i * n + dim) != INT_MIN && !initValNegInf) {
				posMins.push_back(i);
			} else if (C.at(i * n + dim) == INT_MIN && !initValNegInf) {
				posMins.clear();
				posMins.push_back(i);
			} else if (C.at(i * n + dim) == INT_MIN && initValNegInf) {
				posMins.push_back(i);
			}
		}
		if (posMins.size() == 1) {
			return posMins.at(0);
		}
		for (unsigned int j = 0; j < n; j++) {
			if (j != dim) {
				if (initValNegInf) {
					int minVal;
					int normVal = 0;
					if (C.at(posMins.back() * n + j) == INT_MIN) {
						minVal = INT_MIN;
					} else {
						normVal = C.at(posMins.back() * n + j);
						minVal = 0;
					}
					for (int i = posMins.size() - 2; i >= 0; --i) {
						if (C.at(posMins.at(i) * n + j) == INT_MIN && minVal != INT_MIN) {
							minVal = INT_MIN;
							posMins.resize(i + 1);
						} else if (C.at(posMins.at(i) * n + j) != INT_MIN && C.at(posMins.at(i) * n + j) - normVal
								< minVal) {
							minVal = C.at(posMins.at(i) * n + j) - normVal;
							posMins.resize(i + 1);
						} else if (C.at(posMins.at(i) * n + j) != INT_MIN && C.at(posMins.at(i) * n + j) - normVal
								> minVal) {
							posMins.erase(posMins.begin() + j);
						}
					}
				} else {
					int minVal = C.at(posMins.back() * n + j) - C.at(posMins.back() * n + dim);
					for (int i = posMins.size() - 2; i >= 0; --i) {
						if (C.at(posMins.at(i) * n + j) - C.at(posMins.at(i) * n + dim) < minVal) {
							posMins.resize(i + 1);
							minVal = C.at(posMins.at(i) * n + j) - C.at(posMins.at(i) * n + dim);
						} else if (C.at(posMins.at(i) * n + j) - C.at(posMins.at(i) * n + dim) > minVal) {
							posMins.erase(posMins.begin() + j);
						}
					}
				}
				if (posMins.size() == 1) {
					return posMins.at(0);
				}
			}
		}
		std::cout
				<< "Something went horribly wrong. It should not have come to this. The algorithm detected no lexicographic minimal generator. So I'm returning -1 which will make the program crash."
				<< std::endl;
		return -1;
	}

	/*
	 * Function to reset a clock to 0.
	 * The function is also able to handle non normalised polyhedra by resetting to the 0-clock offset
	 * resetVal defaults to 0
	 */
	void VectorizedMPPMarking::ResetClock(int clock, int resetVal) {
		for (unsigned int i = 0; i < gens; i++) {
			if (G.at(i * n) == INT_MIN) {
				G.at(i * n + clock) = INT_MIN;
			} else {
				G.at(i * n + clock) = G.at(i * n) + resetVal;
			}
		}
	}

	/*
	 * Frees up a clock from all constraints
	 * resetVal is passed when called fram Extrapolate to reset the polyhedron to maxBound+1 according to the extrapoltaion algorithm
	 * resetVal defaults to 0 for a regular Free.
	 */
	void VectorizedMPPMarking::FreeClock(int clock, int resetVal) {
		ResetClock(clock, resetVal);
		AddUnitVec(clock);
	}

	void VectorizedMPPMarking::PrintLocal() const {
		std::cout << "Polyhedron ID: " << id << std::endl;
		std::cout << "Placement: ";
		for (unsigned int i = 0; i < NumberOfTokens(); i++) {
			std::cout << GetTokenPlacement(i) << ", ";
		}
		std::cout << std::endl << "Mapping (token:clock): ";
		for (unsigned int i = 0; i < NumberOfTokens(); i++) {
			std::cout << i << ":" << GetClockIndex(i) << ", ";
		}
		std::cout << std::endl << "gens: " << gens << std::endl;
		std::cout << "n: " << n << std::endl;
		std::cout << "G:" << std::endl;
		for (unsigned int i = 0; i < gens; i++) {
			for (unsigned j = 0; j < n; j++) {
				if (j == 0) {
					std::cout << "g" << i << "   ";
				}
				std::cout << G.at(i * n + j) << " ";
				if (j == n - 1) {
					std::cout << std::endl;
				}
			}
		}
		std::cout << std::endl;
	}

	/*
	 * function assumes that any two clocks asked to be swapped are active
	 */

	void VectorizedMPPMarking::Swap(int x, int y) {
		dp.Swap(x, y);
		int xClock = mapping.GetMapping(x);
		int yClock = mapping.GetMapping(y);

		for (unsigned int i = 0; i < gens; i++) {
			int temp = G.at(i * n + xClock);
			G.at(i * n + xClock) = G.at(i * n + yClock);
			G.at(i * n + yClock) = temp;
		}
	}

	//	bool VectorizedMPPMarking::IsUpperPositionGreaterThanPivot(int upper, int pivoxIndex) const{
	/*TODO*/
	//		return false;
	//	}

	void VectorizedMPPMarking::Print(std::ostream& out) const {
		out << "Placement: ";
		for (unsigned int i = 0; i < NumberOfTokens(); i++) {
			out << GetTokenPlacement(i) << ", ";
		}
		out << std::endl;
		out << "Mapping (token:clock): ";
		for (unsigned int i = 0; i < NumberOfTokens(); i++) {
			out << i << ":" << GetClockIndex(i) << ", ";
		}
		out << std::endl;
		out << "G:" << std::endl;
		for (unsigned int i = 0; i < gens; i++) {
			for (unsigned j = 0; j < n; j++) {
				if (j == 0) {
					out << "g" << i << "   ";
				}
				out << G.at(i * n + j);
				if (j == n - 1) {
					out << std::endl;
				}
			}
		}
	}

	id_type VectorizedMPPMarking::UniqueId() const {
		return id;
	}

	unsigned int VectorizedMPPMarking::GetClockIndex(unsigned int token) const {
		return mapping.GetMapping(token);
	}

	/*
	 * Resets a tokens time to 0
	 */
	void VectorizedMPPMarking::Reset(int token) {
		ResetClock(GetClockIndex(token));
		Cleanup();
	}

	/*
	 * function assumes that no calculation bring us out of positive space (delay, intersection, reset etc.)
	 */
	bool VectorizedMPPMarking::IsEmpty() const {
		if (gens == 0 || G.size() == 0) {
			return true;
		}
		for (unsigned int i = 0; i < gens; ++i) {
			if (G.at(i * n) != INT_MIN) {
				return false;
			}
		}

		PrintLocal();
		std::cout << "all tests failed, returning empty\n";
		return true;
	}

	/*
	 * Delay a polyhedra by making a linear copy of all convex generators
	 */
	void VectorizedMPPMarking::Delay() {
		int addGens = 0;
		for (unsigned int i = 0; i < gens; i++) {
			if (G.at(i * n) != INT_MIN) {
				G.resize(G.size() + n);
				addGens++;
				std::memcpy(&G.at((gens - 1 + addGens) * n), &G.at(i * n), sizeof(int) * n);
				G.at((gens - 1 + addGens) * n) = INT_MIN;
			}
		}
		gens += addGens;

		for (unsigned int i = 0; i < NumberOfTokens(); i++) {
			const TAPN::TimeInvariant& invariant = tapn->GetPlace(GetTokenPlacement(i)).GetInvariant();
			if (invariant.GetBound() < INF) {
				Constrain(i, invariant);
			}
		}
		Cleanup();
	}

	/*
	 * freeing the constraints on a token
	 */
	void VectorizedMPPMarking::Free(int token) {
		FreeClock(mapping.GetMapping(token));
		Cleanup();
	}

	/*
	 * NOTE: since we don't have any good representation of strictness with max-plus
	 * polyhedra, there is an implicit conversion of strict constraints to non-strict
	 * with the same bound. This can cause incorrect behaviour.
	 */
	void VectorizedMPPMarking::Constrain(int token, const TAPN::TimeInterval& interval) {
		if (interval.IsLowerBoundStrict() || (interval.IsUpperBoundStrict() && interval.GetUpperBound() != INT_MAX)) {
			std::cout << "lowerbound: " << interval.GetLowerBound() << " - " << interval.IsLowerBoundStrict()
					<< std::endl;
			std::cout << "upperbound: " << interval.GetUpperBound() << " - " << interval.IsUpperBoundStrict()
					<< std::endl;
			std::cout << "Model includes strict constraint(s) - might incur incorrect behaviour\n";
		}

		int clock = GetClockIndex(token);
		std::vector<int> a = std::vector<int>(n, INT_MIN);
		std::vector<int> b = std::vector<int>(n, INT_MIN);
		if (interval.GetUpperBound() != INT_MAX) {
			a.at(clock) = 0;
			b.at(0) = interval.GetUpperBound();
			IntersectHalfspace(a, b);
			Cleanup();
		}
		if (interval.GetLowerBound() > 0) {
			a.at(clock) = INT_MIN;
			b.at(0) = INT_MIN;
			a.at(0) = 0;
			b.at(clock) = -interval.GetLowerBound();
			IntersectHalfspace(a, b);
			Cleanup();
		}
	}
	/*
	 * Since we do not have a good representation for strct constraints with
	 * max-plus polyhedra, in this function there is an implicit conversion of
	 * strict constraints to non-strict. This can cause incorrect behaviour when
	 * dealing with models contain strict constraints.
	 */
	void VectorizedMPPMarking::Constrain(int token, const TAPN::TimeInvariant& invariant) {
		if (invariant.IsBoundStrict() && invariant.GetBound() != INT_MAX) {
			std::cout << "invariant: " << invariant.GetBound() << " - " << invariant.IsBoundStrict() << " == "
					<< INT_MAX << " " << INF << " " << std::numeric_limits<int>::max();
			std::cout << std::endl;
			std::cout << "Model includes strict invariant(s) - might incur incorrect behaviour\n";
		}
		if (invariant.GetBound() != std::numeric_limits<int>::max() && invariant.GetBound() != INF) {
			int clock = GetClockIndex(token);
			std::vector<int> a = std::vector<int>(n, INT_MIN);
			std::vector<int> b = std::vector<int>(n, INT_MIN);
			a.at(clock) = 0;
			b.at(0) = invariant.GetBound();
			IntersectHalfspace(a, b);
		}
	}

	bool VectorizedMPPMarking::PotentiallySatisfies(int token, const TAPN::TimeInterval& interval) const {
		int clock = GetClockIndex(token);
		bool lowerSat = false, upperSat = false;
		if (interval.GetLowerBound() <= 0) {
			if (interval.IsLowerBoundStrict() && interval.GetLowerBound() == 0) {
				std::cout << "Strict bound might incur incorrect result\n";
			}
			lowerSat = true;
		}
		if (interval.GetUpperBound() >= INF) {
			upperSat = true;
		}
		if (upperSat && lowerSat) {
			return true;
		}
		for (unsigned int i = 0; i < gens; i++) {
			if (G.at(i * n) != INT_MIN && G.at(i * n + clock) != INT_MIN) { // second condition should never be able to be false given first is true
				lowerSat = lowerSat || G.at(i * n + clock) - G.at(i * n) >= interval.GetLowerBound();
				upperSat = upperSat || G.at(i * n + clock) - G.at(i * n) <= interval.GetUpperBound();
			} else if (G.at(i * n) == INT_MIN && G.at(i * n + clock) != INT_MIN) {
				lowerSat = true; //generator is delayed and thus always will satisfy a lower bound
			}
			if (upperSat && lowerSat) {
				return true;
			}

		}
		return false;
	}

	/*
	 * extrapolation - not compleate but sound
	 * principles: freeing unbounded clocks, and theorems 4.9 and 4.11
	 */
	void VectorizedMPPMarking::Extrapolate(const int* maxConstants) {
		for (unsigned int j = 1; j < n; ++j) {
			if (maxConstants[j] == -INF) {
				FreeClock(j);
			} else if (maxConstants[j] >= 0) {
				bool addUnitVec = false; //should we add a new unit vector for the given dimension  (j)?
				bool resetExtra = true; //is all generators above maxConstant[j] thus we should apply 4.9?
				for (unsigned int i = 0; i < gens; i++) {
					if (resetExtra) {
						if (G.at(i * n) != INT_MIN && G.at(i * n + j) - G.at(i * n) <= maxConstants[j]) {
							resetExtra = false;
						}
						if (i == gens - 1 && resetExtra) {
							FreeClock(j, maxConstants[j] + 1);
							break;
							resetExtra = false;
						}
					}
					if (!addUnitVec && G.at(i * n + j) != INT_MIN) { //generator has an actual value for concerned dimension
						bool unitVec = true; //is the given generator a unit vector?
						for (unsigned int k = 1; k < n; k++) {
							if (k != j && G.at(i * n + k) != INT_MIN) {
								unitVec = false;
								if (G.at(i * n + j) - G.at(i * n + k) <= maxConstants[j]) {
									break;
								}
							}
							if (k == n - 1 && !unitVec) {
								addUnitVec = true;
								AddUnitVec(j);
							}
						}
					}
				}
			}
		}
		Cleanup();
		//ExtrapolateClaim(maxConstants);
		//Extrapolate49(maxConstants);
		//Extrapolate411(maxConstants);
		//Extrapolate413(maxConstants);
	}

	void VectorizedMPPMarking::ExtrapolateClaim(const int* maxConstants) {
		std::vector<int> topCorner = std::vector<int>(n, INT_MIN);
		std::vector<int> infSupp = std::vector<int>(n, 0);
		for (unsigned int i = 0; i < gens; i++) {
			if (G.at(i * n) != INT_MIN) {
				for (unsigned int j = 0; j < n; j++) {
					topCorner.at(j) = MAX(topCorner.at(j), G.at(i*n+j)-G.at(i*n));
				}
			} else {
				for (unsigned int j = 1; j < n; j++) {
					if (G.at(i * n + j) != INT_MIN) {
						infSupp.at(j) = 1;
					}
				}
			}
		}
		for (unsigned int j = 1; j < n; j++) {
			bool infSuppAllDim = true;
			for (unsigned int k = 1; k < n; k++) {
				if (k != j && !infSupp.at(k)) {
					infSuppAllDim = false;
				}
			}
			for (unsigned int i = 1; i < gens; i++) {
				if (infSuppAllDim) {
					gens++;
					G.resize(gens * n);
					std::memcpy(&G.at((gens - 1) * n), &G.at(i * n), sizeof(int) * n);
					G.at((gens - 1) * n) = INT_MIN;
				} else if (G.at(i * n) != INT_MIN && G.at(i * n + j) - G.at(i * n) > maxConstants[j]) {
					int minDif = INF;
					for (unsigned int k = 1; k < n; k++) {
						if (k != j) {
							minDif = MIN(minDif, topCorner.at(k) - (G.at(i*n+k) - G.at(i*n)));
						}
					}
					if (topCorner.at(j) != G.at(i * n + j) - G.at(i * n)) {
						topCorner.at(j) += minDif;
					}
					G.at(i * n) -= minDif;
				}
			}
		}
		Cleanup();
	}

	void VectorizedMPPMarking::Extrapolate411(const int* maxConstants) {
		for (unsigned int j = 1; j < n; j++) {
			if (maxConstants[j] >= 0) {
				for (unsigned int i = 0; i < gens; i++) {
					if (G.at(i * n) != INT_MIN && G.at(i * n + j) - G.at(i * n) <= maxConstants[j]) {
						break;
					}
					if (i == gens - 1) {
						FreeClock(j, maxConstants[j] + 1);
						break;
					}
				}
			}
		}
		Cleanup();
	}

	void VectorizedMPPMarking::Extrapolate49(const int* maxConstants) {
		for (unsigned int j = 1; j < n; j++) {
			if (maxConstants[j] >= 0) {
				bool addUnitVec = false;
				for (unsigned int i = 0; i < gens; i++) {
					if (!addUnitVec && G.at(i * n + j) != INT_MIN) { //generator has an actual value for concerned dimension
						bool unitVec = true;
						for (unsigned int k = 1; k < n; k++) {
							if (k != j && G.at(i * n + k) != INT_MIN) {
								unitVec = false;
								if (G.at(i * n + j) - G.at(i * n + k) <= maxConstants[j]) {
									break;
								}
							}
							if (k == n - 1 && !unitVec) {
								addUnitVec = true;
							}
						}
						if (addUnitVec) {
							AddUnitVec(j);
							break;
						}
					}
				}
			}
		}
		Cleanup();
	}

	void VectorizedMPPMarking::Extrapolate413(const int* maxConstants) {
		for (unsigned int j = 1; j < n; j++) {
			if (maxConstants[j] >= 0) {
				break;
			}
			if (j == n - 1) {
				return;
			}
		}
		for (unsigned int i = 0; i < gens; i++) {
			if (G.at(i * n) != INT_MIN) {
				for (unsigned int j = 1; j < n; j++) {
					if (G.at(i * n + j) - G.at(i * n) <= maxConstants[j]) {
						break;
					}
					if (j == n - 1) {
						G.resize(G.size() + n);
						memcpy(&G.at(gens * n), &G.at(i * n), sizeof(int) * n);
						G.at(gens * n) = INT_MIN;
						gens++;
					}
				}
			}
		}
		Cleanup();
	}

	/*
	 * adds a unit vector for a specific dimension to the end of G.
	 * Unit vectors e are defined as:
	 * e_j = 0, j == dim
	 * e_j = NegInf, j!= dim
	 */
	void VectorizedMPPMarking::AddUnitVec(unsigned int dim) {
		gens++;
		G.resize(gens * n);
		for (unsigned int j = 0; j < n; j++) {
			if (j == dim) {
				G.at((gens - 1) * n + j) = 0;
			} else {
				G.at((gens - 1) * n + j) = INT_MIN;
			}
		}
	}

	void VectorizedMPPMarking::ConvexUnion(AbstractMarking* marking) {
		VectorizedMPPMarking* mpp = static_cast<VectorizedMPPMarking*> (marking);
		G.resize(G.size() + mpp->G.size());
		memcpy(&G.at(n * gens), &mpp->G.at(0), sizeof(int) * n * mpp->gens);
		gens += mpp->gens;
		Cleanup();
	}

	size_t VectorizedMPPMarking::HashKey() const {
		return VerifyTAPN::hash()(dp);
	}

	relation VectorizedMPPMarking::Relation(const StoredMarking& other) const {
		const VectorizedMPPMarking &mpp = static_cast<const VectorizedMPPMarking&> (other);
		bool sup = Contains(mpp);
		bool sub = mpp.Contains(*this);
		if (sub && sup) {
			return EQUAL;
		}
		if (sub) {
			return SUBSET;
		}
		if (sup) {
			return SUPERSET;
		}
		return DIFFERENT;
	}

	void VectorizedMPPMarking::AddTokens(const std::list<int>& placeIndicies) {
		unsigned int newToken = NumberOfTokens();
		for (std::list<int>::const_reverse_iterator iter = placeIndicies.rbegin(); iter != placeIndicies.rend(); ++iter) {
			for (int i = gens - 1; i >= 0; i--) {
				G.insert(G.begin() + i * n + n, G.at(i * n));
			}
			mapping.SetMapping(newToken, n);
			dp.AddTokenInPlace(*iter);
			newToken++;
			n++;
		}
	}

	void VectorizedMPPMarking::RemoveTokens(const std::set<int>& tokenIndices) {
		//Since we have to remove clocks one at a time, we have to guarantee that we remove them in order.
		std::vector<unsigned int> removeClocks;
		for (std::set<int>::const_reverse_iterator it = tokenIndices.rbegin(); it != tokenIndices.rend(); ++it) {
			removeClocks.push_back(mapping.GetMapping(*it));
			mapping.RemoveToken(*it);
			dp.RemoveToken(*it);
		}
		for (unsigned int j = 0; j < mapping.size(); ++j) {
			int offset = 0;
			unsigned int currentMapping = mapping.GetMapping(j);
			for (std::vector<unsigned int>::iterator it = removeClocks.begin(); it != removeClocks.end(); ++it) {
				if (currentMapping > *it)
					offset++;
			}
			mapping.SetMapping(j, currentMapping - offset);
		}
		for (unsigned int j = 0; j < removeClocks.size(); j++) {
			for (int i = gens - 1; i >= 0; i--) {
				G.erase(G.begin() + n * i + removeClocks.at(j));
			}
			n--;
		}
	}
}

