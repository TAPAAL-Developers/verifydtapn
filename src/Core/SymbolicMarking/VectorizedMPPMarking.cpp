#include "VectorizedMPPMarking.hpp"
#include <cstring>
#include <iostream>
#include <stdio.h>
//#include <xmmintrin.h>

namespace VerifyTAPN {

	boost::shared_ptr<TAPN::TimedArcPetriNet> VectorizedMPPMarking::tapn;

	/* Init function allocating memory and setting all values to INT_MIN which is used to represent negative infinity.
	 * Adding the first (0,0,..,0) generator
	 * n = maximal number of clocks
	 * initGens is an arbitrarily chosen initial number of generators for which space is allocated
	 */
	void VectorizedMPPMarking::InitZero(const unsigned int n) {
		G.reserve(n*initGens);
		G = std::vector<int>(n, INT_MIN);
		AC = std::vector<int>(n, 0);
		this->n = AC.size();
		gens = 1;

		if(NumberOfTokens() > n-1){
			//The initial marking is created before checking if k < initial number of tokens in main. Thus we need to do the check here to avoid an array out of bounds
		}
		else{
			for(unsigned int j = 0; j<= dp.size(); j++){
				AC.at(j)=1;
				G.at(j)=0;
			}
		}
	}

	void VectorizedMPPMarking::InitMapping(){
		for(unsigned int i = 0; i < dp.size(); i++){
			mapping.SetMapping(i, i+1);
		}
	}


	/* Function to calculate whether 1 arbitrary point is contained in (can be
	 * generated by) the polyhedron
	 * x is the vector containing the point
	 * ac is a vector telling which clocks are active
	 * skipGen is used when calculating whether a generator of a polyhedron is redundant. In this case the index of the concerned generator
	 * is passed to indicate that it is not a part of the polyhedron without it
	 * skipGen defaults to -1 which does not macth any generator index
	 */
	bool VectorizedMPPMarking::ContainsPoint(const std::vector<int>& x, int skipGen) const {
		std::vector<int> y = std::vector<int>(gens, INF);
		std::vector<int> z = std::vector<int>(n, INT_MIN);

		for(unsigned int i = 0; i < gens; i++){
			if(i != skipGen){
				for(unsigned int j = 0; j < n; j++){
					if(AC.at(j)){
						if(G.at(i*n+j) == INT_MIN /*|| y.at(i) == INT_MIN*/){
							// y.at(i) does not change since we get MIN(y_val, x_val - -INF) => MIN(y_val, INF)
							// or in the second case we get MIN(-INF, value) => -INF and we know y_i already is -INF
						}
						else if(x.at(j) == INT_MIN){
							y.at(i) = INT_MIN;
						}
						else {
							y.at(i) = MIN(y.at(i), x.at(j) - G.at(i*n+j));
						}
					}
				}
			}
		}
		for(unsigned int j = 0; j<n; j++){
			if(AC.at(j)){
				for(unsigned int i = 0; i< gens; i++){
					if(i != skipGen){
						if(z.at(j) >= INF || y.at(i) >= INF || G.at(i*n+j) >= INF){
							z.at(j) = INF;
							return false; //the generator x we check for containment cannot have the value INF in any dimension
						}
						else if (y.at(i) == INT_MIN || G.at(i*n+j) == INT_MIN) {
							//z.at(j) should not change since we're interested in MAX and the result of y_val + G_val will be -INFINITY
						}
						else {
						z.at(j) = MAX(z.at(j), y.at(i)+G.at(i*n+j));
						}
					}
				}
				if(x.at(j)!=z.at(j)){
					return false;
				}
			}
		}
		return true;
	}

	/* Function to determine whether a given polyhedron is contained in this
	 *
	 */
	bool VectorizedMPPMarking::Contains(const VectorizedMPPMarking& mpp) const {
		std::vector<int> x = std::vector<int>(n);

		//std::vector<int> xAC(n);
		//for(unsigned int j=0;j<n;++j){
		//	xAC.at(j) = mpp.AC.at(j);
		//}

		for(unsigned int i = 0; i< mpp.gens; i++){
			std::memcpy(&x.at(0), &mpp.G.at(i*n), sizeof(int)*n); //extracting one generator from mpp copying it to x

			for(unsigned int j = 0; j<NumberOfTokens(); ++j){
				if(GetClockIndex(j) != mpp.GetClockIndex(j)){
					int temp = x.at(GetClockIndex(j));
					x.at(GetClockIndex(j)) = x.at(mpp.GetClockIndex(j));
					x.at(mpp.GetClockIndex(j)) = temp;

		//			temp = xAC.at(GetClockIndex(j));
		//			xAC.at(GetClockIndex(j)) = xAC.at(mpp.GetClockIndex(j));
		//			xAC.at(mpp.GetClockIndex(j)) = temp;

		//			temp = xMapping.at(j);
		//			xMapping.at(j) =
				}
			}

/*
			bool xACbool = false;

					for(unsigned int j = 0; j<n; j++){ //checking that the active clocks match. THis is probaly handled by the mappign.
						if(AC.at(j)!=xAC.at(j)){
							xACbool = true;
							std::cout << "active clocks does not match:\n";
						}
					}
					if(xACbool){
						PrintLocal();
						mpp.PrintLocal();
						std::cout << "xAC: ";
						for(unsigned int j = 0;j<n;++j){
							std::cout << xAC.at(j) << " ";
						}
						std::cout << std::endl;
						std::cout << "x: ";
						for(unsigned int j = 0;j<n;++j){
							std::cout << x.at(j) << " ";
						}
						std::cout << std::endl;
					}
*/
			if(!ContainsPoint(x)){
			//	PrintLocal();
			//	mpp.PrintLocal();
			//	std::cout << "Returning on g:" << i << std::endl;
				return false;
			}
		}
		return true;
	}

	/* Function to intersect this with a half-space
	 * a max-plus half-space is here used to represent a difference constraint
	 * a and b are generators defining the half-space
	 */
	void VectorizedMPPMarking::IntersectHalfspace(std::vector<int>& a, std::vector<int>& b){
		std::vector<int> Ggt; //"set" G^greather_than
		Ggt.reserve(G.size()); //reserve space to potentially hold all generators of G
		int GgtGens = 0; // number of generators in Ggt

		for(unsigned int i = 0; i< gens; i++){
			int ag = INT_MIN; //to contain max-plus dot products (a * G^i)
			int bg = INT_MIN; //and (b * G^i)
			for(unsigned int j = 0; j<n; j++){
				if(AC.at(j)){
					if(a.at(j) == INT_MIN || G.at(i*n+j) == INT_MIN) {
						//ag is either itself or INT_MIN which it was initialized as
						//a_j + G^i_j = INT_MIN in either case
					}
					else{
						ag = MAX(ag, a.at(j) + G.at(i*n+j));
					}
					if(b.at(j) == INT_MIN || G.at(i*n+j) == INT_MIN){
						//same as above (ag) for bg
					}
					else{
						bg = MAX(bg, b.at(j) + G.at(i*n+j));
					}
				}
			}
			if(ag > bg){
				Ggt.resize(Ggt.size()+n); //resizing Ggt to have space for another generator
				std::memcpy(&Ggt.at(GgtGens*n), &G.at(i*n), sizeof(int)*n); //copying generator to Ggt "set"
				GgtGens++;

				if(i < gens-1){
					std::memcpy(&G.at(i*n), &G.at((gens-1)*n), sizeof(int)*n); //moving last generator to empty space just created from removing a generator
					i--; //loop need to handle just moved generator
				}
				gens--;
				G.resize(gens*n); //resizing g to drop last generator which was just moved (might not be necessary as we keep count of generators and do a additional resize just below)
			}
		}

		int GleqGens = gens;
		G.resize(gens*n + GleqGens*GgtGens*n); //resize to fit the extra generators to be added

		for(int g = 0; g < GleqGens; g++){
			for(int h = 0; h < GgtGens; h++){
				std::vector<int> generator = std::vector<int>(n, INT_MIN);
				int ah = INT_MIN; // to hold dotproduct of a and h
				int bg = INT_MIN; // dot product for b and g
				for(unsigned int j = 0; j<n; j++){
					if(AC.at(j)){
						if(a.at(j) == INT_MIN || Ggt.at(h*n+j) == INT_MIN){

						}
						else {
							ah = MAX(ah, a.at(j)+Ggt.at(h*n+j));
						}
						if(b.at(j) == INT_MIN || G.at(g*n+j) == INT_MIN){

						}
						else {
							bg = MAX(bg, b.at(j)+G.at(g*n+j));
						}
					}
				}
				for(unsigned int j = 0; j<n; j++){
					if(AC.at(j)){
						if(ah == INT_MIN || G.at(g*n+j) == INT_MIN){
							if(bg == INT_MIN || Ggt.at(h*n+j) == INT_MIN){
								//generator.at(j) = INT_MIN which it already is initialised to
							}
							else{
								generator.at(j) = bg+Ggt.at(h*n+j);
							}
						}
						else if(bg == INT_MIN || Ggt.at(h*n+j) == INT_MIN){
							generator.at(j) = ah+G.at(g*n+j);
						}
						else {
							generator.at(j) = MAX(ah+G.at(g*n+j), bg+Ggt.at(h*n+j));
						}
					}
				}
				std::memcpy(&G.at(gens*n), &generator.at(0), sizeof(int)*n); //copying newly created generator into the end of G
				gens++;
			}
		}
	}

	/*
	 * function to remove redundant generators
	 */
	void VectorizedMPPMarking::Cleanup() {
		std::vector<int> g = std::vector<int>(n);
		for(int i = gens-1; i>=0; --i){
			std::memcpy(&g.at(0), &G.at(i*n), sizeof(int)*n); //extracting a generator
			if(ContainsPoint(g, i)){ //passing i to reflect the given generator should be ignored in the containment calculation
				if(i < gens-1){ //checking whether the given generator is the last one or not. If not the last one has to be moved to keep data compact
					std::memcpy(&G.at(i*n), &G.at((gens-1)*n), sizeof(int)*n);
				}
				gens--;
				G.resize(gens*n);
			}
		}
	}

	/*
	 * Function to reset a clock to 0.
	 * The function is also able to handle non normalised polyhedra by resetting to the 0-clock offset
	 * resetVal defaults to 0
	 */
	void VectorizedMPPMarking::ResetClock(int clock, int resetVal){
		for(unsigned int i = 0; i<gens; i++){
			G.at(i*n+clock) = G.at(i*n) + resetVal;
		}
	}

	/*
	 * Frees up a clock from all constraints
	 * resetVal is passed when called fram Extrapolate to reset the polyhedron to maxBound+1 according to the extrapoltaion algorithm
	 * resetVal defaults to 0 for a regular Free.
	 */
	void VectorizedMPPMarking::FreeClock(int clock, int resetVal){
		ResetClock(clock, resetVal);
		gens++;
		G.resize(gens*n);
		for(unsigned int j = 0; j<n; j++){
			if(j == clock){
				G.at((gens-1)*n+j) = 0;
			}
			else{
				G.at((gens-1)*n+j) = INT_MIN;
			}
		}
	}

	void VectorizedMPPMarking::PrintLocal() const{
		std::cout << "Polyhedron ID: " << id << std::endl;
		std::cout << "Placement: ";
		for(unsigned int i = 0; i< NumberOfTokens(); i++){
			std::cout << GetTokenPlacement(i) << ", ";
		}
		std::cout << std::endl << "Mapping (token:clock): ";
		for(unsigned int i = 0; i < NumberOfTokens(); i++){
			std::cout << i << ":" << GetClockIndex(i) << ", ";
		}
		std::cout << std::endl << "n: " << n << std::endl;
		std::cout << "AC" << ":";
		for(unsigned int i=0; i<n; i++){
			std::cout << " " << AC.at(i);
		}
		std::cout << std::endl << "gens: " << gens << std::endl;
		std::cout << "G:" << std::endl;
		for(unsigned int i = 0; i<gens; i++){
			for(unsigned j = 0; j<n; j++){
				if(j == 0){
					std::cout << "g" << i << "   ";
				}
				std::cout << G.at(i*n+j) << " ";
				if(j == n-1){
					std::cout << std::endl;
				}
			}
		}
		std::cout << std::endl;
	}

	/*
	 * function assumes that any two clocks asked to be swapped are active
	 */

	void VectorizedMPPMarking::Swap(int x, int y){
		dp.Swap(x,y);
		int xClock = mapping.GetMapping(x);
		int yClock = mapping.GetMapping(y);
		int tempAC = AC.at(xClock);
		AC.at(xClock) = AC.at(yClock);
		AC.at(yClock) = AC.at(tempAC);

		for(unsigned int i = 0; i<gens; i++){
			int temp = G.at(i*n+xClock);
			G.at(i*n+xClock) = G.at(i*n+yClock);
			G.at(i*n+yClock) = temp;
		}
	}

//	bool VectorizedMPPMarking::IsUpperPositionGreaterThanPivot(int upper, int pivoxIndex) const{
		/*TODO*/
//		return false;
//	}

	void VectorizedMPPMarking::Print(std::ostream& out) const {
		out << "Placement: ";
		for(unsigned int i = 0; i< NumberOfTokens(); i++){
			out << GetTokenPlacement(i) << ", ";
		}
		out << std::endl;
		out << "Mapping (token:clock): ";
		for(unsigned int i = 0; i < NumberOfTokens(); i++){
			out << i << ":" << GetClockIndex(i) << ", ";
		}
		out << std::endl;
		out << "G:" << std::endl;
		for(unsigned int i = 0; i<gens; i++){
			for(unsigned j = 0; j<n; j++){
				if(j == 0){
					out << "g" << i << "   ";
				}
				out << G.at(i*n+j);
				if(j == n-1){
					out << std::endl;
				}
			}
		}
	}

	id_type VectorizedMPPMarking::UniqueId() const {
		return id;
	}

	unsigned int VectorizedMPPMarking::GetClockIndex(unsigned int token) const {
		return mapping.GetMapping(token);
	}

	/*
	 * Resets a tokens time to 0
	 */
	void VectorizedMPPMarking::Reset(int token) {
		ResetClock(GetClockIndex(token));
		Cleanup();
	}

	/*
	 * function assumes that no calculation bring us out of positive space (delay, intersection, reset etc.)
	 */
	bool VectorizedMPPMarking::IsEmpty() const {
		if(!AC.at(0)){
			PrintLocal();
			std::cout << "some error has occured\n";
		}
		if(G.size()==0 || gens == 0){
			return true;
		}
		bool activeClocks = false;
		for(unsigned int j = 1; j<n; ++j){
			if(AC.at(j)){
				activeClocks = true;
				break;
			}
		}
		if(!activeClocks){
			return true;
		}

		for(unsigned int i = 0; i<gens; ++i){
			if(G.at(i*n) != INT_MIN){
				return false;
			}
		}

//		std::vector<int> actualVal(n,0);
//		for(unsigned int i = 0; i<gens; i++){
//			if(G.at(i*n)!=INT_MIN){
//				for(unsigned int j = 1; j<n; ++j){
//					if(AC.at(j) && G.at(i*n+j) != INT_MIN){
//						return false;
//					}
//				}
//			}
//		}
		PrintLocal();
		std::cout << "all tests failed, returning empty\n";
		return true;
	}

	/*
	 * Delay a polyhedra by making a linear copy of all convex generators
	 */
	void VectorizedMPPMarking::Delay() {
		int addGens = 0;
		for(unsigned int i = 0; i<gens; i++){
			if(G.at(i*n) != INT_MIN){
				G.resize(G.size()+n);
				addGens++;
				std::memcpy(&G.at((gens-1+addGens)*n), &G.at(i*n), sizeof(int)*n);
				G.at((gens-1+addGens)*n) = INT_MIN;
			}
		}
		gens += addGens;

		for(unsigned int i = 0; i<NumberOfTokens(); i++){
			const TAPN::TimeInvariant& invariant = tapn->GetPlace(GetTokenPlacement(i)).GetInvariant();
			if(invariant.GetBound() < INF ){
				Constrain(i, invariant);
			}
		}
		Cleanup();
	}

	/*
	 * freeing the constraints on a token
	 */
	void VectorizedMPPMarking::Free(int token) {
		FreeClock(mapping.GetMapping(token));
		Cleanup();
	}

	/*
	 * NOTE: since we don't have any good representation of strictness with max-plus
	 * polyhedra, there is an implicit conversion of strict constraints to non-strict
	 * with the same bound. This can cause incorrect behaviour.
	 */
	void VectorizedMPPMarking::Constrain(int token, const TAPN::TimeInterval& interval) {
		if(interval.IsLowerBoundStrict() || (interval.IsUpperBoundStrict() && interval.GetUpperBound() != INT_MAX)){
			std::cout << "lowerbound: " << interval.GetLowerBound() << " - " << interval.IsLowerBoundStrict() << std::endl;
			std::cout << "upperbound: " << interval.GetUpperBound() << " - " << interval.IsUpperBoundStrict() << std::endl;
			std::cout << "Model includes strict constraint(s) - might incur incorrect behaviour\n";
		}

		int clock = GetClockIndex(token);
		std::vector<int> a = std::vector<int>(n, INT_MIN);
		std::vector<int> b = std::vector<int>(n, INT_MIN);
		if(interval.GetUpperBound() != INT_MAX){
			a.at(clock) = 0;
			b.at(0) = interval.GetUpperBound();
			IntersectHalfspace(a,b);
			Cleanup();
		}
		if(interval.GetLowerBound() > 0){
			a.at(clock) = INT_MIN;
			b.at(0) = INT_MIN;
			a.at(0) = 0;
			b.at(clock) = -interval.GetLowerBound();
			IntersectHalfspace(a,b);
			Cleanup();
		}
	}
	/*
	 * Since we do not have a good representation for strct constraints with
	 * max-plus polyhedra, in this function there is an implicit conversion of
	 * strict constraints to non-strict. This can cause incorrect behaviour when
	 * dealing with models contain strict constraints.
	 */
	void VectorizedMPPMarking::Constrain(int token, const TAPN::TimeInvariant& invariant){
		if(invariant.IsBoundStrict() && invariant.GetBound() != INT_MAX){
			std::cout << "invariant: " << invariant.GetBound() << " - " << invariant.IsBoundStrict() << " == " << INT_MAX << " " << INF << " " << std::numeric_limits<int>::max();
			std::cout << std::endl;
			std::cout << "Model includes strict invariant(s) - might incur incorrect behaviour\n";
		}
		if(invariant.GetBound() != std::numeric_limits<int>::max() && invariant.GetBound() != INF){
			int clock = GetClockIndex(token);
			std::vector<int> a = std::vector<int>(n,INT_MIN);
			std::vector<int> b = std::vector<int>(n,INT_MIN);
			a.at(clock) = 0;
			b.at(0) = invariant.GetBound();
			IntersectHalfspace(a,b);
		}
	}

	bool VectorizedMPPMarking::PotentiallySatisfies(int token, const TAPN::TimeInterval& interval) const {
		int clock = GetClockIndex(token);
		bool lowerSat = false, upperSat = false;
		if(interval.GetLowerBound() <= 0){
			if(interval.IsLowerBoundStrict() && interval.GetLowerBound() == 0){
				std::cout << "Strict bound might incur incorrect result\n";
			}
			lowerSat = true;
		}
		if(interval.GetUpperBound() >= INF){
			upperSat = true;
		}
		for(unsigned int i = 0; i<gens; i++){
			if(G.at(i*n) != INT_MIN && G.at(i*n+clock) != INT_MIN){ // second condition should never be able to be false given first is true
				lowerSat = lowerSat || G.at(i*n+clock)-G.at(i*n) >= interval.GetLowerBound();
				upperSat = upperSat || G.at(i*n+clock)-G.at(i*n) <= interval.GetUpperBound();
			}
			else if(G.at(i*n) == INT_MIN && G.at(i*n+clock) != INT_MIN){
				lowerSat = true; //generator is delayed and thus always will satisfy a lower bound
			}
			if(upperSat && lowerSat){
				return true;
			}

		}
		return false;
	}

	void VectorizedMPPMarking::Extrapolate(const int* maxConstants){
		for(unsigned int j = 1; j<n; ++j){
			if(AC.at(j) && maxConstants[j] == -INF){
				FreeClock(j);
				Cleanup();
			}
		}
	}

	/*
	 * not complete extrapolation however it is sound
	 *
	 * not optimal implementation. The loops of the different parts could in some way be combined
	 */
/*	void VectorizedMPPMarking::Extrapolate(const int* maxConstants) {
		std::vector<int> oneDimExtra(n,0);
		for(unsigned int j = 1; j<n; ++j){
			if(AC.at(j) && maxConstants[j] == -INF){
				FreeClock(j);
				Cleanup();
				continue;
			}
			bool aboveKi = true;
			bool actualCheck = false;
			if(AC.at(j)){
				for(unsigned int i = 0; i<gens; ++i){
					if(!aboveKi){
						break; //breaking inner loop since we've found a generator not satisfying the condition
					}
					if(G.at(i*n) == INT_MIN){
						//skipping generator since it's representing a linear part
						continue;
					}
					if(G.at(i*n+j) == INT_MIN){
						std::cout << "This should not be possible. Some error has occurred\n";
						break;
					}
					aboveKi = G.at(i*n+j) - G.at(i*n) > maxConstants[j];
					actualCheck = true;
				}
				if(aboveKi && actualCheck){
					//std::cout << "free clock " << j << " above max-constant on poly " << id << "max constant = " << maxConstants[j] << std::endl;
					FreeClock(j,maxConstants[j]+1);
					Cleanup();
					oneDimExtra.at(j) = 1;
					//PrintLocal();
				}
			}
		}
		Cleanup();

		//Checking if a given generator is above the diagonal going upwards from each maximal bound
		unsigned int oldGens = gens;
		for(unsigned int i = 0; i<oldGens; ++i){
			for(unsigned int j = 1; j<n; ++j){
				bool addGen = true;
				bool actualCheck = false;
				if(AC.at(j) && maxConstants[j] > 0 && !oneDimExtra.at(j) && G.at(i*n+j) != INT_MIN){
					for(unsigned int k = 1; k<n; ++k){
						if(!AC.at(k) || j == k){
							//breaking loop since given clock is not active
							//or because clocks are the same
							continue;
						}
						else{
							actualCheck=true;
						}
						if(G.at(i*n+k) != INT_MIN || G.at(i*n+j)-G.at(i*n+k) <= maxConstants[j]){
							addGen=false;
						}
					}
					if(addGen&&actualCheck){
						std::vector<int> generator(n,INT_MIN);
						generator.at(j) = 0;
						G.resize(G.size()+n);
						memcpy(&G.at(G.size()-n), &generator.at(0), sizeof(int)*n);
						gens++;
						oneDimExtra.at(j) = 1;
						std::cout<<"adding one dim ex on clock: " << j << " polyhedron: " << id << std::endl;
					}
				}
			}
		}
		Cleanup();

		// Checking if convex generators are in the upper quadrant
		// if so, a linear copy of the generator is made
		oldGens = gens;
		for(unsigned int i = 0; i<oldGens; ++i){
			bool upperCorner = true;
			bool actualCheck = false;
			for(unsigned int j = 1; j<n; ++j){
				if(!upperCorner || G.at(i*n) == INT_MIN){
					break; //breaking inner loop since current generator has been determined not to be in the upper quadrant
					//or because the generators reference clock is INT_MIN and thus already represents a delayed generator
				}
				if(AC.at(j)){
					if(G.at(i*n+j)==INT_MIN){
						//do nothing since generator produce no value on the given clock
						//should not be possible to get here though
					}
					else{
						upperCorner = G.at(i*n+j)-G.at(i*n) > maxConstants[j];
						actualCheck = true;
					}
				}
			}
			if(upperCorner && actualCheck){
				G.resize(G.size()+n);
				memcpy(&G.at(G.size()-n), &G.at(i*n), sizeof(int)*n);
				G.at(G.size()-n) = INT_MIN; //setting refence clock of new generator = INT_MIN
				gens++;
			}
		}
		Cleanup();
		return;
	}*/

	void VectorizedMPPMarking::ConvexUnion(AbstractMarking* marking) {
		VectorizedMPPMarking* mpp = static_cast<VectorizedMPPMarking*>(marking);
		G.resize(G.size()+mpp->G.size());
		memcpy(&G.at(n*gens), &mpp->G.at(0), sizeof(int)*n*mpp->gens);
		gens += mpp->gens;
		Cleanup();
	}

	size_t VectorizedMPPMarking::HashKey() const {
		return VerifyTAPN::hash()(dp);
	}

	relation VectorizedMPPMarking::Relation(const StoredMarking& other) const {
		const VectorizedMPPMarking &mpp = static_cast<const VectorizedMPPMarking&>(other);
		bool sup = Contains(mpp);
		bool sub = mpp.Contains(*this);
		if(sub && sup){
			return EQUAL;
		}
		if(sub){
			return SUBSET;
		}
		if(sup){
			return SUPERSET;
		}
		return DIFFERENT;
	}

	void VectorizedMPPMarking::AddTokens(const std::list<int>& placeIndicies) {
		std::vector<int> freeClocks;
		freeClocks.reserve(placeIndicies.size());
		unsigned int newToken = NumberOfTokens();

		for(unsigned int j = 1; j<AC.size(); j++){
			if(!AC.at(j) && freeClocks.size() < placeIndicies.size()){
				freeClocks.push_back(j);
			}
		}
		if(freeClocks.size() > 0){//making sure we don't add more clocks than allowed
			for(std::list<int>::const_reverse_iterator iter = placeIndicies.rbegin(); iter != placeIndicies.rend(); ++iter){
				int clock = freeClocks.back();
				for(unsigned int i = 0; i<gens; i++){
					G.at(i*n+clock) = G.at(i*n);
				}
				mapping.SetMapping(newToken, clock);
				AC.at(clock) = 1;
				freeClocks.pop_back();
				dp.AddTokenInPlace(*iter);
				newToken++;
			}
		}
		else {
			std::cout << "No more free clocks due to some error" << std::endl;
		}
	}

	void VectorizedMPPMarking::RemoveTokens(const std::set<int>& tokenIndices) {
		//std::vector<int> tokenVec = std::vector<int>(dp.size(),0);
	//	std::cout << "Remove Tokens, size of tokenIndices: " << tokenIndices.size() << std::endl;
		int bugus = 0;
		for(std::set<int>::const_reverse_iterator it = tokenIndices.rbegin(); it!=tokenIndices.rend(); ++it){
			int clock = mapping.GetMapping(*it);
			AC.at(clock) = 0;
			for(unsigned int i = 0; i<gens; i++){
				G.at(i*n+clock) = INT_MIN;
			}
			//tokenVec.at(*it) = 1;
			mapping.RemoveToken(*it);
			dp.RemoveToken(*it);
		}
		//mapping.RemoveListOfTokens(tokenVec);
		//dp.RemoveListOfTokens(tokenVec);
	}
}
